{"posts":[{"title":"Computer Network Lab 1: Switchyard &amp; Mininet","text":"实验网站：https://nju-cn-course.gitbook.io/nju-computer-network-lab-manual/lab-1 实验名称Lab 1: Switchyard &amp; Mininet 实验目的了解计算机网络实验环境和基本操作 实验内容Step 1: Modify the Mininet topology在拓扑中删除。 我们在类的构造函数中创建一个拓扑。若想要删除server2，则需修改类的构造函数，具体到本次操作，即不进行server 2和hub的连接，同时不再设置server2的mac和ip。 代码修改部分如下： 123456789#在结点列表中删除server2#不再将server2连接到hubfor node in nodes.keys(): if node != &quot;server2&quot;: self.addHost(node, **nodeconfig)for node in nodes.keys(): # all links are 10Mb/s, 100 millisecond prop delay if node != &quot;hub&quot; and node != &quot;server2&quot;: self.addLink(node, &quot;hub&quot;, bw=10, delay=&quot;100ms&quot;) 1234567#取消设置server2的mac和ipdef setup_addressing(net): for node, config in nodes.items(): if node != &quot;server2&quot;: reset_macs(net, node, config[&quot;mac&quot;]) if node != &quot;hub&quot; and &quot;server2&quot;: set_ip(net, node, &quot;hub&quot;, config[&quot;ip&quot;]) Step 2: Modify the logic of a device任务是计算有多少数据包通过集线器进出。 设置两个变量cnt_in和cnt_out记录通过集线器进出的数据包的数量，并在循环过程中进行统计和输出信息。 代码修改部分如下： 1234567891011121314151617181920212223242526272829303132333435def main(net: switchyard.llnetbase.LLNetBase): my_interfaces = net.interfaces() mymacs = [intf.ethaddr for intf in my_interfaces] #初始化计数变量cnt_in和cnt_out cnt_in = 0 cnt_out = 0 while True: try: _, fromIface, packet = net.recv_packet() except NoPackets: continue except Shutdown: break log_debug (f&quot;In {net.name} received packet {packet} on {fromIface}&quot;) #每收到一个数据包，更新cnt_in cnt_in = cnt_in + 1 eth = packet.get_header(Ethernet) if eth is None: log_info(&quot;Received a non-Ethernet packet?!&quot;) return if eth.dst in mymacs: log_info(&quot;Received a packet intended for me&quot;) else: for intf in my_interfaces: if fromIface!= intf.name: log_info (f&quot;Flooding packet {packet} to {intf.name}&quot;) net.send_packet(intf, packet) #每发送一个数据包，更新cnt_out cnt_out = cnt_out + 1 log_info(&quot;in:{} out:{}&quot;.format(cnt_in, cnt_out)) net.shutdown() Step 3: Modify the test scenario of a device使用new_packet函数创建一个新的测试用例并进行测试。 在myhub_testscenario.py中新增如下代码作为新的测试用例： 1234567891011121314151617181920#test case 4: a frame with broadcast destination should get sent out# all ports except ingresstestpkt = new_packet( &quot;20:00:00:00:00:01&quot;, &quot;ff:ff:ff:ff:ff:ff&quot;, &quot;192.168.1.100&quot;, &quot;255.255.255.255&quot; )s.expect( PacketInputEvent(&quot;eth1&quot;, testpkt, display=Ethernet), (&quot;An Ethernet frame with a broadcast destination address &quot; &quot;should arrive on eth1&quot;) )s.expect( PacketOutputEvent(&quot;eth0&quot;, testpkt, &quot;eth2&quot;, testpkt, display=Ethernet), (&quot;The Ethernet frame with a broadcast destination address should be &quot; &quot;forwarded out ports eth0 and eth2&quot;) ) 测试结果如图： Step 4: Run your device in Mininet在Mininet中运行Switchyard​程序。 以下为运行记录截图： Step 5: Capture using Wireshark在拓扑中创造一些流量并使用Wireshark​​捕获数据包。 执行server1 ping -c 1 hub进行测试 以下为测试记录： 可以看到，server1向client发送了一个请求并得到了回复。","link":"/2024/03/17/Computer-Network-Lab-1-Switchyard-Mininet/"},{"title":"《计算机网络：自顶向下方法》课后习题","text":"Textbook Charpter 1R12Description与分组交换网络相比，电路交换网路有哪些优点？在电路交换网络中，TDM与FDM相比有哪些优点？ Solution 电路交换相比于分组交换的优点 在电路交换网络中，在端系统通信会话期间，预留了端系统间沿路径通信所需要的资源，在连接期间在该网络链路上预留了恒定的传输速率，发送方能够以确保的恒定速率向接收方传送数据。 TDM相比于FDM的优点 FDM的信号转换更加复杂 R23Description因特网协议栈中的5个层次是什么？在这些层次中，每层的主要任务是什么？ Solution 应用层 应用层是网络应用及它们的应用层协议存留的地方。 运输层 因特网的运输层在应用程序端点之间传送应用层报文。 网络层 因特网的网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。 链路层 ​ 将整个帧从一个网络元素移动到邻近的网络元素。 物理层 将帧中的一个个比特从一个节点移动到下一个节点。 R24Description什么是应用层报文？什么是运输层报文段？什么是网络层数据报？什么是链路层帧？ Solution 应用层报文：位于应用层的信息分组。 运输层报文段： 运输层分组。由应用层报文和运输层首部信息构成。 网络层数据报： 网络层分组。在运输层报文段的基础上增加了如源和目的端系统地址等网络层首部信息。 链路层帧： 链路层分组。在网络层数据报的基础上增加链路层首部信息。 R25Description路由器处理因特网协议栈中的哪些层次？链路层交换机处理的是哪些层次？主机处理的是哪些层次？ Solution 路由器：物理层、链路层和网络层 链路层交换机： 物理层和链路层 主机： 物理层、链路层、网络层、运输层和应用层","link":"/2024/03/22/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98/"},{"title":"算法设计与分析习题","text":"K-sortedTitleSuppose that, instead of sorting an array, we just require that the elements increase on average. More precisely, we call an n-element array a k-sorted if for all $i = 1, 2, …, n-k$, the following holds: $\\frac{\\sum_{j=i}^{i+k-1}A[j]}{k}\\le\\frac{\\sum_{j=i+1}^{i+k}A[j]}{k}$​​ Given an algorithm that k-sorts an n-element array in $O(nlog(n/k))$time. Show that a k-sorted array of length n can be sorted in $O(nlogk)$ time. Solution对于第一问，分别对如下的集合进行排序即可： $A[1],A[1+k],A[1+2k],…$ $A[2],A[2+k],A[2+2k],…$ $A[3],A[3+k],A[3+2k],…$ $…$​ 对于第二问，可抽象为合并$k$个有序表，具体实现可用堆完成： 初始堆中放入每个有序表的表头 每次操作从堆中取出一个最小值，并使对应表的头指针右移 共$n$个元素，堆中元素个数不超过$k$个，即每次操作时间复杂度为$O(logk)$，整体时间复杂度为$O(nlogk)$","link":"/2024/03/20/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"Computer Network","slug":"Computer-Network","link":"/tags/Computer-Network/"}],"categories":[{"name":"Computer Network","slug":"Computer-Network","link":"/categories/Computer-Network/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}],"pages":[]}